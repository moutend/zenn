---
title: "（実践Cloudflare Workers）Service bindingsあるいはGateway Workerパターンの紹介"
emoji: "🗂"
type: "tech"
topics: [Cloudflare, "Cloudflare Pages", "Cloudflare Workers"]
published: false
---
## はじめに

Cloudflare WorkersにはBindings（バインディング）とよばれる仕組みがあります。バインディングを設定すると、オブジェクトストレージのR2やリレーショナルデータベースのD1など、Cloudflareが提供する別のサービスをWorkerから直接操作できるようになります。Service bindingsはバインディングの一種であり、Worker同士で通信するための仕組みです。

もちろん、Service bindingsを使わなくても通常の`fetch()`でWorker同志の通信は行えます。しかし、以下の問題があります。

1. インターネットを経由した通信になるためレイテンシーが生じる。
2. 非公開のWorker同士で通信できない。
3. どのWorker同士が連携しているのかCloudflareのダッシュボード上で把握できない。

これらの問題を解決できるのがService bindingsです。通信はインターネットを経由せずCloudflareの閉じられたネットワーク内で完結するため、通常の`fetch()`と比較してレイテンシーは無視できるほど小さくなります。また、インターネットを経由しないため非公開のWorker同士で通信可能になります。

今回はサーバーレス・エッジコンピューティングの視点でService bindingsの紹介をします。フロントエンドのJavaScriptフレームワークやCDNをからめた説明はしませんので、その点はご留意ください。

## 環境

記事の投稿にあたり、以下の環境にて動作確認を行いました。

- wranglerコマンドのバージョン: v3.1.2
- wrangler.tomlファイルの`compatibility_date`: 2023-06-28

Service bindingsは誰でも利用できる状態です。ただし、リリースされたのが2022年11月31日です。まだ日が浅いサービスですので、大きな変更が加わる可能性があります。意図しない挙動に遭遇した場合は公式ドキュメントを参照してください。

## Workerの作成

それでは、3つのWorkerを作成しましょう。記事の説明のために親しみを込めた名前をつけましたが、深い理由はありません。各自でお好みの名前をつけていただいてOKです。

1. りんごWorker
2. バナナWorker
3. さくらんぼWorker

それぞれのWorkerを作成するには`npm create cloudflare@latest`でHello Workerテンプレートを選んでください。その後、`wrangler.toml`と`src/worker.ts`を編集してください。

### りんごWorkerの概要

りんごWorkerの概要は次のとおりです。

- 非公開のWorkerです。インターネット経由のアクセスはできません。
- GETリクエストを受け取ると以下のプロパティを含むJSONをレスポンスとして返します。
  - `timestamp`: レスポンスを返した時刻
  - `random`: ランダムな値

**レスポンスの例**

```json
{
  "timestamp": 1689031924677,
  "random": 4032682106
}
```

#### `wrangler.toml`

```toml
name = "apple"
usage_model = "bundled"
main = "src/worker.ts"
compatibility_date = "2023-06-28"
workers_dev = false
```

#### `src/worker.ts`

```ts
export default {
	async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
		const values = new Uint32Array(1);

		crypto.getRandomValues(values);

		return Response.json({
			timestamp: new Date().getTime(),
			random: values[0],
		});
	},
};
```

### バナナWorkerの概要

バナナWorkerの概要は次のとおりです。

- 非公開のWorkerです。インターネット経由のアクセスはできません。
- 独自のHTTPヘッダーとして`Happy-Message`を受け取ります。
- POSTリクエストのみ受け付けます。POSTでなければ400 Bad requestエラーを返します。
- リクエストのペイロードはJSONです。プロパティとして`happiness`を含みます。
- レスポンスとしてJSONを返します。
  - `Happy-Message`ヘッダーで指定されたメッセージを返します。
  - メッセージは`happiness`プロパティで指定された回数繰り返します。

**リクエストの例**

```text
Happy-Message: "I'm happy!"

{
  happiness: 3
}
```

**レスポンスの例**

```json
{
  "message": "I'm happy! I'm happy! I'm happy!"
}
```

#### `wrangler.toml`

```toml
name = "banana"
usage_model = "bundled"
main = "src/worker.ts"
compatibility_date = "2023-06-28"
workers_dev = false
```

#### `src/worker.ts`

```ts
interface BananaRequest {
	happiness: number;
}

export default {
	async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
		if (request.method !== 'POST') {
			return new Response('Oops!', { status: 400 });
		}

		const body: BananaBody = await request.json();
		const happiness = body.happiness > 0 && body.happiness < 10 ? body.happiness : 1;
		const message = request.headers.get('Happy-Message') + ' ';

		return Response.json({
			message: message.repeat(happiness).trim(),
		});
	},
};
```

### さくらんぼWorkerの概要

さくらんぼWorkerの概要は次のとおりです。

- インターネットに公開されます。
- りんごWorkerとバナナWorkerにHTTPリクエストを送信します。

コードの詳細については次のセクションで説明します。

#### `wrangler.toml`

```toml
name = "cherry"
usage_model = "bundled"
main = "src/worker.ts"
compatibility_date = "2023-06-28"

services = [
  { binding = "Worker1", service = "apple" },
  { binding = "Worker2", service = "banana" }
]
```

#### `src/worker.ts`

```ts
export interface Env {
	Worker1: Fetcher;
	Worker2: Fetcher;
}

interface Worker1Response {
	timestamp: number;
	random: number;
}

interface Worker2Response {
	message: string;
}

export default {
	async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
		const response1 = await env.Worker1.fetch(request.clone());
		const response2 = await env.Worker1.fetch(request.clone());
		const response3 = await env.Worker2.fetch(request.url, {
			cf: request.cf,
			method: 'POST',
			headers: new Headers({
				...request.headers,
				'Content-Type': 'application/json',
				'Happy-Message': "I'm happy!",
			}),
			body: JSON.stringify({
				happiness: 3,
			}),
		});

		const body1: ResponseBody = await response1.json();
		const body2: ResponseBody = await response2.json();
		const body3: ResponseBody = await response3.json();

		return Response.json({
			worker1: {
				first: { ...body1 },
				second: { ...body2 },
			},
			worker2: {
				...body3,
			},
		});
	},
};
```

#### レスポンスの例

```json
{
  "worker1": {
    "first": {
      "timestamp": 1689031924677,
      "random": 4032682106
    },
    "second": {
      "timestamp": 1689031924677,
      "random": 2321664665
    }
  },
  "worker2": {
    "message": "I'm happy! I'm happy! I'm happy!"
  }
}
```

## コードの解説

## 実装の注意点

## 参考資料
