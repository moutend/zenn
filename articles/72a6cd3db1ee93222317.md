---
title: "ターミナルの作り方（macOS編）"
emoji: "🐕"
type: "tech"
topics: [macOS ターミナル 自作 iTerm2 Swift]
published: false
---
# はじめに

普段なにげなく使っているものを一から自作したい、それは人類の根源的な欲求の一つです。もちろんターミナルも例外ではありません。

この記事ではiTerm2的なターミナルエミュレーターアプリ（以降はターミナルと省略）の作り方を説明します。前提知識なしで読み進められるように考慮しているので安心して読み進めてください。

# 擬似端末（）について

まずはmacOSに搭載されているターミナルを起動して`tty`と入力してください。

```console
$ tty
/dev/ttys000
```

上記のように表示されるはずです。

続けて`Command + T`で新規タブを開いてから、もう一度`tty`を入力してください。

```console
$ tty
/dev/ttys001
```

この`/dev/ttys000`や`/dev/ttys001`が擬似端末（）です。

# 擬似端末への書き込み

実験してみましょう。`Command + 1`で1つめのタブに切り替えてから、以下のコマンドを入力してください。

```console
$ echo hello > /dev/ttys001
```

その後、`Command + 2`で2つめのタブに切り替えてください。すると、`hello`と表示されているはずです。

```console
$ hello
```

この実験から、擬似端末への書き込みは画面への出力に対応していることが確認できました。

# 擬似端末からの読み取り

別の実験をしましょう。`Command + 1`で1つめのタブに切り替えてから以下のコマンドを実行してください。

```console
$ cat /dev/ttys001
```

次に`Command + 2`で2つめのタブに切り替えてから、何でも良いのでキーボードを連打してください。ひとまず、`a`を連打してみましょう。

```console
$ aaaaaaaaaaaaaaaa...
```

`Command + 1`で1つめのタブに切り替えてください。すると、2つめのタブで入力した値が表示されているはずです。

```console
$ cat /dev/ttys001
aaaaaaaaaaaaaaaa...
```

ところで、キーボードを連打している時に違和感を覚えたはずです。もう一度`Command + 2`で2つめのタブに切り替えてから、今度は`pwd`と入力してみましょう。

```console
# pwdと入力しているのに一部の文字が表示されない
$ p
```

`pwd`と入力したのに一部の文字が入力できなかったはずです。あるいは全く文字が入力できなかったかもしれません。これは正常な動作ですので安心してください。

この挙動は2つめのタブで実行しているシェルと1つめのタブで実行している`cat /dev/ttys001`が擬似端末の入力を同時に読み取っているため発生します。`Command + 1`で1つめのタブに切り替えてください。入力したときに欠けていた文字が表示されているはずです。

```console
$ cat /dev/ttys001
wd
```

この実験から、擬似端末の読み取りはキーボード入力の読み取りに対応していることが確認できました。

# アプリ実装の流れ

ターミナルの作り方がおぼろげながら浮かんできました。

- 擬似端末ファイル（`/dev/ttysXXX`）を作る
- シェルの標準入出力と擬似端末ファイルの入出力を接続する
- アプリが受け取ったキーボード入力を擬似端末に渡す
- 擬似端末から受け取った出力をアプリに渡して画面を描画する

大雑把ではありますが、上記がアプリ実装の流れになります。

# 擬似端末の作り方

`posix_openpt()`を実行すると擬似端末のマスターファイルとスレーブファイルのペアが作成されます。このとき作成されたスレーブファイルはシェルに接続します。すると、マスターファイルへの書き込みはシェルの入力として、マスターファイルの読み取りはシェルの出力として扱われます。

## 実装例

それでは擬似端末を作ってみましょう。キーボード入力を受け付ける代わりに1秒ごとに`date`コマンドを入力する実装例を示します。

```swift
import Darwin
import Foundation

class PTY {
    var task = Process()

    var slaveFile: FileHandle
    var masterFile: FileHandle

    init() {
        let masterFD = posix_openpt(O_RDWR)

        grantpt(masterFD)
        unlockpt(masterFD)

        self.masterFile = FileHandle.init(fileDescriptor: masterFD)

        let slavePath = String.init(cString: ptsname(masterFD))

        self.slaveFile = FileHandle.init(forUpdatingAtPath: slavePath)!

        self.task.executableURL = URL(fileURLWithPath: "/bin/bash")
        self.task.arguments = ["-i"]

        self.task.standardOutput = slaveFile
        self.task.standardInput = slaveFile
        self.task.standardError = slaveFile

        DispatchQueue.global(qos: .default).async {
            do {
                try self.task.run()
            } catch {
                fatalError("failed to start task: \(error)")
            }
        }
        DispatchQueue.global(qos: .default).async {
            while true {
                let data = self.masterFile.availableData
                let output = String(data: data, encoding: String.Encoding.utf8)!

                print(output)
            }
        }
    }
    func write(_ input: String) {
        self.masterFile.write("\(input)\u{0d}".data(using: String.Encoding.utf8)!)
    }
}

var pty = PTY()

for _ in 0 ..< 5 {
    pty.write("date")
    sleep(1)
}
```

## 解説

上記のコードで行っている処理を説明します。

1. `posix_openpt()`を実行してマスターファイルのディスクリプたを取得する
2. `grantpt()`と`unlockpt()`を実行して擬似端末のセットアップを行う
3. マスターファイルを作成する
4. `ptsname()`を実行してスレーブファイルのパスを取得する
5. そのパスを指定してスレーブファイルを作成する
6. スレーブファイルをシェルの標準入出力に接続する
7. マスターファイルの読み書きを行う

補足になりますが、今回はひとまず`/bin/bash`をシェルとしてハードコードしています。もちろん、bashでもzshでも、シェルは何を指定しても構いません。

さらに補足になりますが、PTYクラスの`write()`メソッドでは文字列に`\u{08}`を連結しています。これはリターンキーのエスケープシーケンス`0x08`を意味します。

## 試運転

それでは試運転してみましょう。上記のSwiftコードを`main.swift`として保存したら以下のコマンドを入力してください。

```console
$ swift main.swift
```

実行すると以下のように出力されます。私のターミナルはデフォルトのシェルをzshに設定しているため、chshの使い方が表示されていますが、その点は無視してください。

```console
$ swift main.swift
date
The default interactive shell is now zsh.
To update your account to use zsh, please run `chsh -s /bin/zsh`.
For more details, please visit https://support.apple.com/kb/HT208050.
bash-3.2$ dat
e
Sat Aug  7 20:11:25 JST 2021
bash-3.2$
da
te
Sat Aug  7 20:11:26 JST 2021
bash-3.2$
date
Sat Aug  7 20:11:27 JST 2021
bash-3.2$
d
ate
Sat Aug  7 20:11:28 JST 2021
bash-3.2$
date
Sat Aug  7 20:11:29 JST 2021
bash-3.2$
```

`date`コマンドがbashシェル上で実行されていることが確認できました。

なお、`date`の入力が途中で途切れて改行が挟まれているのは意図した挙動です。マスターファイルの読み書きは逐次行われるため、読み書きが同時に行われるとタイミングによっては上記のような表示のずれが発生します。

# UIを実装する

# 参考資料

- [Build A Simple Terminal Emulator In 100 Lines of Golang](https://ishuah.com/2021/03/10/build-a-terminal-emulator-in-100-lines-of-go/)
