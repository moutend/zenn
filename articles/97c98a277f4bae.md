---
title: "入門Cloudflare Workers"
emoji: "🙆"
type: "tech"
topics: [Cloudflare TypeScript JavaScript V8]
published: false
---
## はじめに

この記事はCloudflare Workersの入門記事です。

1. 名前は聞いたことがあるけれどCloudflare Workersが何者なのか知らない方
2. 「Cloudflare Workersはサーバーレス・エッジコンピューティングサービスだよ」と説明されて日本語でOKと感じた方
3. AWSのLambdaやGCPのCloud Functionsと似たようなサービスだろうと認識されている方

上記に当てはまる方のお役に立てるはずです。なお、記事を読み進める上で必須ではありませんが、TypeScriptの読み書きができるとスムーズに理解できると思います。

## 環境構築

記事を読み進めるために、まずは環境構築を行いましょう。といっても、最新のnode.jsをインストールするだけです。

インストールできたらバージョンを確認しておきましょう。

```console
$ node --version
v19.6.0
```

**補足**

- v16.13.0より新しいバージョンのnodeが必要になります。記事を読み進めて不具合が発生した場合はnodeのバージョンを確認してください。
- Windowsでの動作検証はしていません。ここから先の手順については問題なく動作するはずですが、不具合が発生した場合はWSLなどのLinux環境を利用してください。

## サインアップ

それではCloudflare Workersを使ってみましょう。なんと無料で使えるFreeプランが用意されています。太っ腹ですね。

もちろんクレジットカードの登録は不要です。気づかない間に課金されてクラウド破産することはありません。ご安心ください。

トップページのリンクは以下になります。Sign upをクリックしてサインアップを行いましょう。

- [Home - Cloudflare Workers®](https://workers.cloudflare.com)

## サブドメインの設定

サインアップが完了したら[Cloudflareのトップページ](https://www.cloudflare.com)を開いてLoginをクリックしてください。ログインするとダッシュボードが表示されます。

Cloudflare Workersはプロジェクトごとに`https://プロジェクト名.サブドメイン.workers.dev`を発行してくれます；。サブドメインは自由に設定できます。

ダッシュボードのWorkersをクリックするとサブドメインの入力が求められます。お好みのサブドメインを設定してください。

以降はサブドメインとして`example`を設定したものと仮定して説明を進めます。

## wranglerのセットアップ

続いてwranglerのセットアップを行います。wranglerはCloudflare Workersを操作するためのCLIツールです。

もちろんCloudflare Workersはダッシュボードから操作できます。しかし、ダッシュボードの見た目は今後変更されるかもしれません。そうするとスクリーンショットを貼り付けた説明では混乱する恐れがあります。

そこで、wranglerを利用して説明することにします。一度コマンドを覚えれば作業効率もアップします。

### インストール

以下のコマンドを実行してください。

```console
$ npm install -g wrangler
```

インストールが終わったら、以下のコマンドを実行してください。バージョンが表示されたらwranglerのインストールは成功です。

```console
$ npx wrangler --version
 ⛅️ wrangler 2.14.0
```

### 認証

インストールしただけではwranglerを利用できません。認証が必要になります。`npx wrangler login`を実行してください。

参考までに実行令を示します。

```console
$ npx wrangler login
 ⛅️ wrangler 2.14.0
--------------------
Attempting to login via OAuth...
Opening a link in your default browser: https://dash.cloudflare.com/oauth2/auth?response_type=code&client_id=...
```

上記のメッセージが表示された後にブラウザが起動します。URLが間違いなくcloudflare.comであることを確認してからAllowボタンをクリックしてください。

認証が成功すると「Successfully logged in.」と表示されます。

```console
$ npx wrangler login
 ⛅️ wrangler 2.14.0
--------------------
Attempting to login via OAuth...
Opening a link in your default browser: https://dash.cloudflare.com/oauth2/auth?response_type=code&client_id=...
Successfully logged in.
```

以上でwranglerのセットアップは完了です。

## Hello, World!

準備は整いました。次のステップは「Hello, World!」です。

### プロジェクトの初期化

まずはプロジェクトの初期化を行いましょう。ここではプロジェクト名として`hello`を設定することにします。

以下のコマンドを実行してください。

```console
$ npx wrangler init hello
```

初期化の際にいくつか質問されます。今回は以下のように答えました。

- gitで管理しますか？ → no
- TypeScriptを使いますか？ → yes
- Vitestのテストを作成しますか？ → no

今回はサンプルということでgitの管理とテストコードの生成は外しました。TypeScriptは必須ではありません。説明を進める上で都合が良いためTypeScriptを選んだだけです。

参考までに、コマンドの実行結果を示します。初期化が成功すると`hello`ディレクトリが生成されます。

```console
$ npx wrangler init hello
 ⛅️ wrangler 2.14.0
-------------------------------------------------------
Using npm as package manager.
✨ Created hello/wrangler.toml
✔ Would you like to use git to manage this Worker? … no
✔ No package.json found. Would you like to create one? … yes
✨ Created hello/package.json
✔ Would you like to use TypeScript? … yes
✨ Created hello/tsconfig.json
✔ Would you like to create a Worker at hello/src/index.ts? › Fetch handler
✨ Created hello/src/index.ts
✔ Would you like us to write your first test with Vitest? … no
(⠂⠂⠂⠂⠂⠂⠂⠂⠂⠂⠂⠂⠂⠂⠂⠂⠂⠂) ⠋ idealTree:hello: sill idealTree buildDeps
npm WARN deprecated rollup-plugin-inject@3.0.2: This package has been deprecated and is no longer maintained. Please use @rollup/plugin-inject.
npm WARN deprecated sourcemap-codec@1.4.8: Please use @jridgewell/sourcemap-codec instead

added 104 packages, and audited 105 packages in 20s

12 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
✨ Installed @cloudflare/workers-types and typescript into devDependencies

To start developing your Worker, run `cd hello && npm start`
To publish your Worker to the Internet, run `npm run deploy`
```

### 生成されたファイルの確認

生成されたファイルを確認しましょう。helloディレクトリに移動して`src/index.ts`を開いてください。

記事の執筆時点では以下のコードが生成されました。

```ts
/**
 * Welcome to Cloudflare Workers! This is your first worker.
 *
 * - Run `wrangler dev src/index.ts` in your terminal to start a development server
 * - Open a browser tab at http://localhost:8787/ to see your worker in action
 * - Run `wrangler publish src/index.ts --name my-worker` to publish your worker
 *
 * Learn more at https://developers.cloudflare.com/workers/
 */

export interface Env {
  // Example binding to KV. Learn more at https://developers.cloudflare.com/workers/runtime-apis/kv/
  // MY_KV_NAMESPACE: KVNamespace;
  //
  // Example binding to Durable Object. Learn more at https://developers.cloudflare.com/workers/runtime-apis/durable-objects/
  // MY_DURABLE_OBJECT: DurableObjectNamespace;
  //
  // Example binding to R2. Learn more at https://developers.cloudflare.com/workers/runtime-apis/r2/
  // MY_BUCKET: R2Bucket;
  //
  // Example binding to a Service. Learn more at https://developers.cloudflare.com/workers/runtime-apis/service-bindings/
  // MY_SERVICE: Fetcher;
}

export default {
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext
  ): Promise<Response> {
    return new Response("Hello World!");
  },
};
```

### コードの解説

生成された`src/index.ts`について説明します。

まず、冒頭のコメントはCloudflare Workersの紹介文ですから読み飛ばしてください。このコメントは削除しても構いません。

次は`Env`インターフェースの定義です。Cloudflareは様々なサービスを提供しており、それらと連携する際に必要になります。発展的な内容になるため、ひとまず読み飛ばしましょう。

最後は関数定義です。`async fetch`と書かれている部分に注目してください。これがWorkerのエントリーポイントになります。

### 処理の流れ

fetch関数で実行される処理について、流れを説明します。

1. HTTPリクエストを受け取る
2. 何らかの処理を行う
3. HTTPレスポンスを返す

以上です。

大まかに言えば、Workerはfetch関数の実行単位です。Cloudflareのサーバーにリクエストが到着するとWorkerが作成されて、fetch関数が実行されます。fetch関数の実行が完了するとWorkerは削除されます。

そして、Cloudflare WorkersはWorkerのホスティングサービスです。サーバーを構築することなくサーバーサイドの処理を実装できるため「サーバーレス」とよばれています。

### リクエストとレスポンス

改めてfetch関数に注目してください。引数の`Request`と戻り値の`Response`はJavaScript標準APIで定義されているインターフェースに準拠しています。

- [Request - Web APIs - MDN](https://developer.mozilla.org/en-US/docs/Web/API/Request)
- [Response - Web APIs - MDN](https://developer.mozilla.org/en-US/docs/Web/API/Response)

例えばリクエストのヘッダーを参照したい場合`request.headers`で参照できます。リクエストとレスポンスの構造については各自でMDNのドキュメントを参照してください。

なおfetch関数には第3の引数として`ctx: ExecutionContext`が定義されています。こちらも`Env`インターフェースと同様に発展的な内容になるため、説明をスキップします。

### 手元のマシンで動作確認する

お待たせしました。動作確認の時間です。まずは手元のマシンでWorkerを動かしてみましょう。

以下のコマンドを実行してください。

```console
$ npx wrangler dev
```

デフォルトでは`http://localhost:8787`でリクエストを待ち受けます。

それではcurlコマンドを使ってリクエストを投げてみましょう。以下のように表示されたら成功です。

```console
$ curl http://localhost:8787
Hello, World!
```

おめでとうございます、「Hello, World!」が表示されました！

なお、レスポンスに改行文字「`\n`」を含めていないため、実際には「Hello, World!$ 」のようにプロンプトの文字「`$`」が続けて表示されるはずです。気になる方は`\n`を追加してください。

### インターネットに公開する

さぁ、おもしろいのはここからです。以下のコマンドを実行してください。

```console
$ npx wrangler publish
```

これでインターネットを経由してWorkerにアクセスできるようになりました。curlコマンドを実行してみてください。

```console
$ curl https://hello.example.workers.dev
Hello, World!
```

素晴らしい！

## 利用例の検討

ここからはCloudflare Workersがどのような場面で利用できるか検討します。

### ロジックの隠蔽

まず考えられるのが、ロジックの隠蔽です。例えば、以下のような処理をWorkerで実行するとします。

```ts
export interface Env {
  // ...
}

const omikuji = ["大吉", "中吉", "小吉"];

export default {
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext
  ): Promise<Response> {
    const i = Math.floor(Math.random() * omikuji.length);

    return new Response(omikuji[i]);
  },
};
```

おみくじをを引くWorkerです。リクエストごとにランダムな結果が帰ってきます。

```console
$ curl http://localhost:8787
小吉
$ curl http://localhost:8787
大吉
$ curl http://localhost:8787
大吉
```

難読化してもクライアントサイドのJavaScriptは解析される恐れがあります。そこで、解析されて困るロジックをWorkerで実行することで隠蔽します。

おみくじを例に考えましょう。

- どのような候補が定義されているか？
- 候補の中から1つを選択する処理はどのように実装されているか？

クライアントサイドJavaScriptにおみくじが実装されている場合、上記について解析される恐れがあります。これを隠蔽するのにCloudflare Workersは最適です。

### cfプロパティを用いたコンテンツの配信

fetch関数のRequestインターフェースに注目してください。実はCloudflareが独自に定義したcfプロパティが追加されています。

- [Request - Cloudflare Workers docs](https://developers.cloudflare.com/workers/runtime-apis/request/)

多くのcfプロパティが用意されているのですが、ここでは以下をピックアップします。

- `country`: 国コード
- `asn`: AS番号
- `asOrganization`: AS組織名

上記のcfプロパティを返す実装例を示します。

```ts
export interface Env {
  // ...
}

export default {
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext
  ): Promise<Response> {
    const response = JSON.stringify(
      {
        country: request.cf.country,
        asn: request.cf.asn,
        asOrganization: request.cf.asOrganization,
      },
      null,
      2
    );

    return new Response(response);
  },
};
```

実行すると以下のような結果が得られます。

```console
$ curl http://localhost:8787
{
  "country": "JP",
  "asn": 9605,
  "asOrganization": "NTT Docomo"
}
```

例として、docomo回線のスマホにテザリングしてcurlコマンドを実行してみました。リクエストがどのネットワークから送られているのか、正しく判定されています。

例えばニュースフィードを実装するとして、`country`の値でユーザーが居住している国ごとにコンテンツを出汁分けることができます。`asn`の値を記録しておけば、トラブルが発生したときに原因の切り分けに役立つかもしれません。

#### ローカルで動作確認する際の注意事項

さて、勘の鋭い方は`http://localhost:8787`にリクエストを送信していることに気がついたはずです。`http://localhost:8787`は説明のための例ではなく、本当に`http://localhost:8787`にリクエストを送信しています。

基本的に`npx wrangler dev`で起動したWorkerはCloudflare Workersのサーバー上で実行されるWorkerと同じ振る舞いをします。そのため、`npx wrangler publish`することなく動作を確認することができます。

従って、ローカルで動作確認をする場合もインターネットに接続されている必要があります。

## Cloudflare Workersを深く知る

Cloudflare Workersの便利さを実感できたでしょうか。ここからはCloudflare Workersを使いこなすために把握しておくべき項目について説明します。

### Workerは世界中にデプロイされる

ここまで何度か`npx wrangler publish`を実行しました。その際、デプロイ先のサーバーは指定しませんでした。

デプロイしたコードはどのサーバーで実行されるのでしょうか？日本に設置されているサーバーでしょうか、米国に設置されているサーバーでしょうか？

答えは世界中です。

それでは、本当に世界中のサーバーにデプロイされるのか確認しましょう。リクエストのcfプロパティにはリクエストが到着したデータセンターを識別する`colo`プロパティが用意されています。

> colo string
> 
> The three-letter IATA airport code of the data center that the request hit, for example, "DFW".
> 
> （引用元）https://developers.cloudflare.com/workers/runtime-apis/request/#incomingrequestcfproperties

ドキュメントからの引用のとおり、cfプロパティの`colo`に格納されるのはデータセンター最寄りの空港を示す文字列です。

以下のコードを`npx wrangler publish`でデプロイしてください。

```ts
export interface Env {
  // ...
}

export default {
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext
  ): Promise<Response> {
    const response = JSON.stringify(
      {
        country: request.cf.country,
        colo: request.cf.colo,
        asn: request.cf.asn,
        asOrganization: request.cf.asOrganization,
      },
      null,
      2
    );

    return new Response(response);
  },
};
```

以下、AWS EC2からCloudflare Workersに向けてリクエストを送信したときの結果を示します。検証を行ったリージョンは米国のバージニア北部（us-east-1a）と日本の東京（ap-northeast-1a）です。末尾に`1a`とあるように、AZはそれぞれ1aを選んでいます。

| リクエストの送信元 | country | colo | asn | asOrganization |
|:---|:---|:---|:---|:---|
| AWS EC2 us-east-1a | `US` | `IAD` | `14618` | `Amazon.com` |
| AWS EC2 ap-northeast-1a | `JP` | `NRT` | `16509` | `Amazon.com` |

ご覧のとおり、`colo`の値が変化しています。リクエストの送信元に最も近いデータセンターにコードがデプロイされていることを確認できました。

さらに追加で検証してみましょう。以下にレスポンスが返ってくるまでの時間を測定した結果を示します。

@@@

仮にデプロイ先が米国のみであれば日本からのリクエストは太平洋を横断することになります。しかし、リクエストがどこから送信されたかに関わらずレスポンスが帰ってくるまでの時間は（多少の振れ幅はありますが）ほぼ均一です。

この結果から、リクエストの送信元に最も近いデータセンターが選択されており、それらのデータセンターで同じコードが動作していることが確認できます。

#### coloに格納される値

余談になりますが、Cloudflareのドキュメントによると日本国内のCloudflareサーバーは東京・大阪・福岡・那覇の4都市に配置されているそうです。

- （参考）[Cloudflare Global Network - Data Center Locations - Cloudflare](https://www.cloudflare.com/network/)

ここで先ほどの検証結果を見てみると、`colo`の値が`HND`（羽田空港）ではなく`NRT`（成田空港）と表示されています。Cloudflareは千葉を東京圏内と判定しているのか、あるいは`colo`の割り振りは大雑把なのか、その点はよくわかりません。

大阪の場合は関西空港と伊丹空港どちらが選ばれるのでしょうか、気になります。名古屋のように東京と大阪の中間地点からリクエストを送信した場合の挙動も気になります。

とはいえ、そもそも`colo`の値に依存した処理を実装するべきではありません。せっかく冗長化されているわけですから、それを生かした実装を考えるべきです。

### ランタイム

ここまでランタイムについては触れていませんでした。サーバーレスとはいえ、仕組みがどうなっているか把握しておくことは必要です。

まず、Cloudflare WorkersのJavaScriptランタイムにはV8が使われています。V8はnode.jsやChromiumで採用されているJavaScriptランタイムです。別の言い方をすれば、CloudflareのサーバーでホストされているV8をCloudflare Workersと命名したのだと考えて差し支えないでしょう。

V8は関数を実行するためのサンドボックスを提供します。サンドボックスはリクエストごとに作成されるため、Worker同士でメモリが共有されることはありません。Cloudflare WorkersはVMやコンテナの代わりにV8を採用することで軽量な仮想化を実現していると言えます。

ブラウザでタブを開いた状況をイメージしてください。例えば、github.comを開いたタブとzenn.devを開いたタブがあるとします。それぞれのタブは隔離されているため、互いの通信を盗み見たり勝手にスクリプトを操作したりできません。V8は仮想化ソフトウェアではありませんが、仮想化と同等の機能を実現していると言えます。

- （参考）[How Workers works - Cloudflare Workers docs](https://developers.cloudflare.com/workers/learning/how-workers-works/)

従って、Cloudflare Workersではプロセス間の通信などは行えません。また、異なるWorker同士で処理の結果を共有する場合はCloudflare KV、処理の結果を永続化する場合はCloudflare R2などの別サービスと連携する必要があります。

#### グローバル変数

ところで、メモリの話に関連して注意が必要な箇所があります。グローバル変数です。以下のコードをみてください。

```ts
export interface Env {
  // ...
}

var count = 0;

export default {
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext
  ): Promise<Response> {
    count += 1;

    return new Response(count);
  },
};
```

（説明を簡単にするためcount変数のロックは考慮していません）

上記はアクセスカウンターです。リクエストを受け取る旅にグローバル変数`count`がインクリメントされます。

紛らわしいのですが、サンドボックスで隔離されるのはWorker単位です。例えば`https://aaa.example.workers.dev`と`https://bbb.example.workers.dev`があるとします。当然お互いのグローバル変数にはアクセスできません。しかし、同じWorkerであれば実行時の環境は引き継がれるためグローバル変数が参照できます。

さらに紛らわしいのですが、`npx wrangler dev`を実行してローカルでWorkerを動作させる場合とCloudflareのサーバーでWorkerを動作させる場合を比べると、挙動が異なるように見えてしまいます。

**ローカルで実行した結果**

```console
$ curl http://localhost:8787
1
$ curl http://localhost:8787
2
$ curl http://localhost:8787
3
```

**Cloudflareのサーバーで実行した結果**

```console
$ curl https://count.example.workers.dev
1
$ curl https://count.example.workers.dev
1
$ curl https://count.example.workers.dev
1
```

Cloudflareのサーバーで実行されるWorkerは冗長化されています。つまり、上記の例で1番目・2番目・3番目のリクエストを受け取ったWorkerはそれぞれ異なります。

一見すると正しくインクリメントされていないように見えますが、それぞれのWorkerでは正しくインクリメントされています。そのため、偶然に同じWorkerにリクエストが渡されるとアクセスカウンターがインクリメントされる可能性はあります。

そもそもグローバル変数に依存した処理を実装するべきではありません。CloudflareのドキュメントにもWorkerがどのタイミングで揮発するのか言及がありません。

基本的には、リクエストのたびにWorkerが作成されて、処理の完了と同時にWorkerが破棄されると考えて処理を実装するべきです。

### CPU利用時間とメモリ容量の制限

あんなこといいな、できたらいいなと検討中の皆様に残念なお知らせがあります。Cloudflare Workersには以下の制限が設けられています。

**Worker単位の制限**

| 項目 | 無料プラン | 有料プラン |
|:---|:---|:---|
| CPUの利用時間 | 10 ms | 50 ms |
| メモリ容量 | 128 MB | 128 MB |
| 環境変数の個数 | 64個 | 128個 |
| 環境変数の容量 | 5 KB | 5 KB |
| Worker自体の容量 | 1 MB | 5 MB |

- （参照）[Limits - Cloudflare Workers docs](https://developers.cloudflare.com/workers/platform/limits/#worker-limits)

注目していただきたいのがCPUの利用時間です。数値の単位の`ms`は`minutes`の省略形ではありません。10ミリ秒です。

「たったの10ミリ秒！？これじゃあ`Hello, World!`の文字列を返すくらいしか使い道がないよ。」と思われるかもしれません。

しかし、悲観するのは待ってください。以下のコードを実行してみましょう。

```ts
export interface Env {
  // ...
}

async function sleep(milliSecond: number): Promise<string> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("done");
    }, milliSecond);
  });
}

export default {
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext
  ): Promise<Response> {
    const message = await sleep(5000);

    return new Response(message);
  },
};
```

#### CPU利用時間の制限に到達するとどうなるか

```console
$ curl http://localhost:8787; ok $?
<html>
<head><title>504 Gateway Time-out</title></head>
<body>
<center><h1>504 Gateway Time-out</h1></center>
<hr><center>cloudflare</center>
</body>
</html>
```

## おわりに

## 参考資料

1. [Get started guide - Cloudflare Workers docs](https://developers.cloudflare.com/workers/get-started/guide/)
2. [Building a To-Do List with Workers and KV - The Cloudflare Blog](https://blog.cloudflare.com/building-a-to-do-list-with-workers-and-kv/)
3. [How Workers works - Cloudflare Workers docs](https://developers.cloudflare.com/workers/learning/how-workers-works/)
