---
title: "ï¼ˆSwiftï¼‰Accelerateãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®vDSPã‚’åˆ©ç”¨ã—ã¦é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã™ã‚‹"
emoji: "ðŸ˜º"
type: "tech"
topics: [Apple, iOS, Swift, vDSP, ãƒ‡ã‚¸ã‚¿ãƒ«ä¿¡å·å‡¦ç†]
published: true
---
## ã¯ã˜ã‚ã«

Accelerateãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’åˆ©ç”¨ã™ã‚‹ã¨æ•°å€¤è¨ˆç®—ã‚„ãƒ‡ã‚¸ã‚¿ãƒ«ä¿¡å·å‡¦ç†ã‚’é«˜é€Ÿã‹ã¤çœé›»åŠ›ã§å®Ÿè¡Œã§ãã¾ã™ã€‚vDSPã¯Accelerateãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã«å«ã¾ã‚Œã‚‹æ©Ÿèƒ½ã®ä¸€ã¤ã§ã‚ã‚Šã€ãƒ‡ã‚¸ã‚¿ãƒ«ä¿¡å·å‡¦ç†ã‚’æ‹…å½“ã—ã¾ã™ã€‚

vDSPã«ã¯1æ¬¡å…ƒã®é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚’è¡Œã†`vDSP.FFT`ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®æ©Ÿèƒ½ã¯iOS 14ã‹ã‚‰åˆ©ç”¨å¯èƒ½ã§ã™ã€‚Accelerateãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¯AppleãŒæä¾›ã™ã‚‹æ¨™æº–ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã‚ã‚Šè¿½åŠ ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ä½œæ¥­ãªã©ã¯ä¸è¦ã§ã™ã€‚

## vDSPã‚’åˆ©ç”¨ã—ãŸFFT

vDSPã‚’åˆ©ç”¨ã—ãŸFFTã®å®Ÿè£…ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚

```swift
import Accelerate

// ãƒ€ãƒŸãƒ¼ã®ä¿¡å·ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°ã§ã™ã€‚å‘¨æ³¢æ•°ã¨æŒ¯å¹…ã®ãƒšã‚¢ãŒæ ¼ç´ã•ã‚ŒãŸé…åˆ—ã‚’å—ã‘å–ã‚Šã€è¤‡æ•°ã®ã‚µã‚¤ãƒ³æ³¢ãŒåˆæˆã•ã‚ŒãŸä¿¡å·ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
func synthesizeSignal(frequencyAmplitudePairs: [(f: Float, a: Float)], count: Int) -> [Float] {
  let tau: Float = .pi * 2
  let signal: [Float] = (0..<count).map { index in
    frequencyAmplitudePairs.reduce(0) { accumulator, frequenciesAmplitudePair in
      let normalizedIndex = Float(index) / Float(count)
      return accumulator + sin(normalizedIndex * frequenciesAmplitudePair.f * tau)
        * frequenciesAmplitudePair.a
    }
  }

  return signal
}

// FFTã®ã‚µãƒ³ãƒ—ãƒ«æ•°ã¯2048ã¨ã—ã¾ã™ã€‚
let n = vDSP_Length(2048)

let frequencyAmplitudePairs = [
  (f: Float(2), a: Float(0.8)),
  (f: Float(7), a: Float(1.2)),
  (f: Float(24), a: Float(0.7)),
  (f: Float(50), a: Float(1.0)),
]

// å‘¨æ³¢æ•°ã¨æŒ¯å¹…ã®ãƒšã‚¢ã‹ã‚‰ãƒ€ãƒŸãƒ¼ã®ä¿¡å·ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
let signal = synthesizeSignal(frequencyAmplitudePairs: frequencyAmplitudePairs, count: Int(n))

// FFTã®ã‚µãƒ³ãƒ—ãƒ«æ•°ã¯æŒ‡æ•°ã§æŒ‡ç¤ºã—ã¾ã™ã€‚
let log2n = vDSP_Length(log2(Float(n)))

// åŠ¹çŽ‡çš„ã«FFTã®é †æ–¹å‘ãƒ»é€†æ–¹å‘è¨ˆç®—ã‚’ã™ã‚‹ãŸã‚ã€äº‹å‰ã«ä¸‰è§’é–¢æ•°ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½œæˆã—ã¾ã™ã€‚
guard let fftSetUp = vDSP.FFT(log2n: log2n, radix: .radix2, ofType: DSPSplitComplex.self) else {
  fatalError("Can't create FFT Setup.")
}

// ä¿¡å·ã¯ãƒŠã‚¤ã‚­ã‚¹ãƒˆå‘¨æ³¢æ•°ã§æŠ˜ã‚Šè¿”ã•ã‚Œã‚‹ãŸã‚ã€å…¥å‡ºåŠ›ã®é…åˆ—ã®é•·ã•ã‚’`FFTã®ã‚µãƒ³ãƒ—ãƒ«æ•° / 2`ã¨ã—ã¾ã™ã€‚
let halfN = Int(n / 2)

// å…¥åŠ›ã¨å‡ºåŠ›ã«ã¤ã„ã¦ã€è¤‡ç´ æ•°ã®å®Ÿéƒ¨ã¨è™šéƒ¨ã‚’åˆ¥ã€…ã®é…åˆ—ã¨ã—ã¦ä½œæˆã—ã¾ã™ã€‚
var forwardInputReal = [Float](repeating: 0, count: halfN)
var forwardInputImag = [Float](repeating: 0, count: halfN)
var forwardOutputReal = [Float](repeating: 0, count: halfN)
var forwardOutputImag = [Float](repeating: 0, count: halfN)

forwardInputReal.withUnsafeMutableBufferPointer { forwardInputRealPtr in
  forwardInputImag.withUnsafeMutableBufferPointer { forwardInputImagPtr in
    forwardOutputReal.withUnsafeMutableBufferPointer { forwardOutputRealPtr in
      forwardOutputImag.withUnsafeMutableBufferPointer { forwardOutputImagPtr in
        // å…¥åŠ›ä¿¡å·ã‚’æ ¼ç´ã™ã‚‹`DSPSplitComplex`ã‚’ä½œæˆã—ã¾ã™ã€‚
        var forwardInput = DSPSplitComplex(
          realp: forwardInputRealPtr.baseAddress!, imagp: forwardInputImagPtr.baseAddress!)

        // `signal`ã®å®Ÿæ•°å€¤ã‚’è¤‡ç´ æ•°ã«å¤‰æ›ã—ã¾ã™ã€‚
        signal.withUnsafeBytes {
          vDSP.convert(
            interleavedComplexVector: [DSPComplex]($0.bindMemory(to: DSPComplex.self)),
            toSplitComplexVector: &forwardInput)
        }

        // FFTã®çµæžœã‚’å—ã‘å–ã‚‹ãŸã‚ã«`DSPSplitComplex`ã‚’ä½œæˆã—ã¾ã™ã€‚
        var forwardOutput = DSPSplitComplex(
          realp: forwardOutputRealPtr.baseAddress!, imagp: forwardOutputImagPtr.baseAddress!)

        // é †æ–¹å‘ã®FFTã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
        fftSetUp.forward(input: forwardInput, output: &forwardOutput)
      }
    }
  }
}

let autospectrum = [Float](unsafeUninitializedCapacity: halfN) {
  autospectrumBuffer, initializedCount in
  // `vDSP_zaspec`é–¢æ•°ã¯å‡ºåŠ›ã‚’è“„ç©ã—ã¾ã™ã€‚ã‚¹ãƒšã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—ã™ã‚‹å‰ã«åˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„`autospectrumBuffer`ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã€‚
  vDSP.clear(&autospectrumBuffer)

  forwardOutputReal.withUnsafeMutableBufferPointer { forwardOutputRealPtr in
    forwardOutputImag.withUnsafeMutableBufferPointer { forwardOutputImagPtr in
      var frequencyDomain = DSPSplitComplex(
        realp: forwardOutputRealPtr.baseAddress!, imagp: forwardOutputImagPtr.baseAddress!)

      vDSP_zaspec(&frequencyDomain, autospectrumBuffer.baseAddress!, vDSP_Length(halfN))
    }
  }

  initializedCount = halfN
}

// ã‚¹ãƒšã‚¯ãƒˆãƒ©ãƒ ã‹ã‚‰å‘¨æ³¢æ•°ã¨æŒ¯å¹…ã®ãƒšã‚¢ã‚’æ±‚ã‚ã¾ã™ã€‚
let componentFrequencyAmplitudePairs = autospectrum.enumerated().filter {
  $0.element > 1
}.map {
  return ($0.offset, sqrt($0.element) / Float(n))
}

for pair in componentFrequencyAmplitudePairs {
  print("frequency: \(pair.0), amplitude: \(String(format: "%.2f", pair.1))")
}
```

ä¸Šè¨˜ã¯Apple Developerãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«æŽ²è¼‰ã•ã‚Œã¦ã„ã‚‹Swiftã‚³ãƒ¼ãƒ‰ã‚’ä¸€éƒ¨å¤‰æ›´ã—ã¦æ³¨é‡ˆã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’åŠ ãˆãŸã‚‚ã®ã§ã™ã€‚å…ƒã®å®Ÿè£…ã«ã¤ã„ã¦ã¯ä»¥ä¸‹ã‚’å‚ç…§ãã ã•ã„ã€‚

- [Finding the component frequencies in a composite sine wave - Apple Developer Documentation](https://developer.apple.com/documentation/accelerate/finding_the_component_frequencies_in_a_composite_sine_wave)

## ï¼ˆãŠã¾ã‘ï¼‰ä½Žé€ŸãªFFT

vDSPãŒã©ã‚Œã»ã©é«˜é€Ÿãªã®ã‹ç¢ºã‹ã‚ã‚‹ãŸã‚ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã‚ãšã«FFTã‚’å®Ÿè£…ã—ã¾ã™ã€‚å®Ÿè£…æ–¹æ³•ã«ã¤ã„ã¦ã¯ä»¥ä¸‹ã®è¨˜äº‹ã‚’å‚è€ƒã«ã—ã¾ã—ãŸã€‚

- [é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›(FFT)ã‚’ãŠã˜ã•ã‚“ã‚‚C++ã§ä½œã£ã¦ã¿ãŸã‚ˆ - nursã®æ—¥è¨˜](https://nurs.hatenablog.com/entry/20130617/1371483633)

```swift
import Foundation

struct Complex64 {
  let real: Float
  let imag: Float
}

extension Complex64 {
  static func + (left: Complex64, right: Complex64) -> Complex64 {
    return Complex64(real: left.real + right.real, imag: left.imag + right.imag)
  }
  static func += (left: inout Complex64, right: Complex64) {
    left = left + right
  }
  static func - (left: Complex64, right: Complex64) -> Complex64 {
    return Complex64(real: left.real - right.real, imag: left.imag - right.imag)
  }
  static func -= (left: inout Complex64, right: Complex64) {
    left = left - right
  }
  static func * (left: Complex64, right: Complex64) -> Complex64 {
    return Complex64(
      real: left.real * right.real - left.imag * right.imag,
      imag: left.real * right.imag + left.imag * right.real)
  }
  static func *= (left: inout Complex64, right: Complex64) {
    left = left * right
  }
}

func getIndex(_ length: Int) -> [Int] {
  let pow = Int(log2(Float(length)))
  var index: [Int] = []

  index.append(0)
  index.append(1)

  for _ in 0..<(pow - 1) {
    let indexLength = index.count

    for j in 0..<index.count {
      index[j] *= 2
    }
    for j in 0..<indexLength {
      index.append(index[j])
    }
    for j in indexLength..<index.count {
      index[j] += 1
    }
  }

  return index
}

func forward(signal: [Float]) -> [Complex64] {
  let length = signal.count
  let index = getIndex(length)
  let pow = Int(log2(Float(length)))

  var output = [Complex64]()

  for i in 0..<length {
    output.append(Complex64(real: signal[index[i]], imag: 0.0))
  }

  var po2 = 1

  for _ in 1...pow {
    po2 = po2 << 1

    let po2m = po2 >> 1
    let theta = 2.0 * Double.pi / Double(po2)
    let w = Complex64(real: Float(cos(theta)), imag: -Float(sin(theta)))

    var ws = Complex64(real: 1.0, imag: 0.0)

    for k in 0..<po2m {
      for j in stride(from: 0, to: length, by: po2) {
        let wfb = ws * output[j + k + po2m]

        output[j + k + po2m] = output[j + k] - wfb
        output[j + k] += wfb
      }

      ws *= w
    }
  }

  return output
}
```

### å®Ÿè¡Œæ™‚é–“ã®æ¯”è¼ƒ

MacBook Pro 14ã‚¤ãƒ³ãƒ 2021å¹´ãƒ¢ãƒ‡ãƒ«ã§å®Ÿè¡Œæ™‚é–“ã‚’è¨ˆæ¸¬ã—ã¾ã—ãŸã€‚FFTã®ã‚µãƒ³ãƒ—ãƒ«ã‚µã‚¤ã‚ºã¯32768ã¨ã—ã¾ã—ãŸã€‚ä»¥ä¸‹ã®å€¤ã¯ãã‚Œãžã‚Œ10å›žå®Ÿè¡Œã—ãŸä¸­å¤®å€¤ã§ã™ã€‚

çµæžœ

- æ‰‹ä½œæ¥­ã§å®Ÿè£…ã—ãŸFFT: 66.428 ms
- vDSPã‚’åˆ©ç”¨ã—ãŸFFT: 0.076 ms

ãŠã‚ˆã900å€ã®é«˜é€ŸåŒ–ãŒé”æˆã•ã‚Œã¦ã„ã¾ã™ã€ã‚„ã£ãŸã­ï¼

## å‚è€ƒè³‡æ–™

1. [Accelerate - Apple Developer Documentation](https://developer.apple.com/documentation/accelerate)
2. [vDSP - Apple Developer Documentation](https://developer.apple.com/documentation/accelerate/vdsp-snv)
3. [vDSP.FFT - Apple Developer Documentation](https://developer.apple.com/documentation/accelerate/vdsp/fft)
4. [Finding the component frequencies in a composite sine wave - Apple Developer Documentation](https://developer.apple.com/documentation/accelerate/finding_the_component_frequencies_in_a_composite_sine_wave)
5. [Understanding data packing for Fourier transforms - Apple Developer Documentation](https://developer.apple.com/documentation/accelerate/understanding_data_packing_for_fourier_transforms#3695951)
